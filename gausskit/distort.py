#!/usr/bin/env python3
"""
distort.py — Distort geometries along Gaussian vibrational modes.

Features
- Base geometry: external XYZ (standard or headerless) OR geometry extracted from a Gaussian log
  (Standard/Input orientation; first/last table).
- Parses "Frequencies --" blocks and the following "Atom  AN  X  Y  Z ..." displacement tables.
- Generates ± displacements for selected modes and/or random linear combinations (RMS-normalized to --amp Å).
- Optional Gaussian .com outputs with Link-0 (%OldChk/%Chk) lines placed directly above the route line.
- Two interfaces:
    1) Flag-based (argparse) for automation.
    2) Interactive wizard (no flags) with tab completion for both .log and .xyz in one prompt.

Examples
1) List modes:
   gausskit distort --log freq.log --list

2) Use geometry FROM LOG (last Standard orientation) and displace along modes 1–3:
   gausskit distort --log freq.log --geom-source log --modes 1 2 3 --amp 0.08 --out-prefix seed

3) Same, but also write .com files:
   gausskit distort --log freq.log --geom-source log --modes 1 2 3 --amp 0.08 \
     --gaussian --route "#p uWB97X-D/def2-svp scf=(pimom,novaracc) guess=read chkbasis nosymm" \
     --charge -1 --mult 22 --oldchk GS.chk --chk-prefix ES_seed

4) External headerless XYZ + 8 random combos:
   gausskit distort --xyz coords.xyz --log freq.log --random 8 --amp 0.06 --out-prefix rand

5) Interactive wizard (no flags):
   gausskit distort
"""

import argparse
import math
import random
import re
import sys
from pathlib import Path
from typing import List, Tuple, Optional

from prompt_toolkit import prompt
from prompt_toolkit.completion import PathCompleter

# Reuse GaussKit utilities (already in your repo)
from gausskit.utils import prompt_and_submit, MultiPathCompleter

# ----------------------------- periodic table (Z -> symbol) -----------------------------
PT = ["",  # 0 unused
"H","He","Li","Be","B","C","N","O","F","Ne",
"Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca",
"Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn",
"Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr",
"Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn",
"Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd",
"Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb",
"Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg",
"Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th",
"Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm",
"Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Ds",
"Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"
]

# ----------------------------- basic I/O -----------------------------

_EL = re.compile(r'^[A-Za-z][a-z]?$')  # element symbol like H, He, O, Gd

def read_xyz(path: Path) -> Tuple[List[str], List[List[float]]]:
    """
    Robust XYZ reader:
      - Standard XYZ: first line int N, second line comment, then N 'El x y z ...'
      - Headerless XYZ: just lines of 'El x y z ...'
    Returns (labels, coords[Å]).
    """
    raw = [ln.strip() for ln in path.read_text(errors="ignore").splitlines()
           if ln.strip() != ""]
    if not raw:
        raise ValueError("Empty XYZ file.")

    # Try standard header
    try:
        n = int(raw[0])
        if len(raw) < 2 + n:
            raise ValueError(f"Header says {n} atoms, but only {len(raw)-2} coord lines present.")
        recs = raw[2:2+n]
        labels, coords = [], []
        for i, ln in enumerate(recs, start=1):
            parts = ln.split()
            if len(parts) < 4 or not _EL.match(parts[0]):
                raise ValueError(f"Bad XYZ record #{i}: {ln!r}")
            labels.append(parts[0])
            coords.append([float(parts[1]), float(parts[2]), float(parts[3])])
        return labels, coords
    except ValueError:
        # Headerless: treat every 'El x y z ...' as an atom line
        labels, coords = [], []
        for ln in raw:
            parts = ln.split()
            if len(parts) >= 4 and _EL.match(parts[0]):
                labels.append(parts[0])
                coords.append([float(parts[1]), float(parts[2]), float(parts[3])])
        if not labels:
            raise ValueError("Could not detect any 'El x y z' coordinate lines.")
        return labels, coords

def write_xyz(path: Path, labels: List[str], coords: List[List[float]]) -> None:
    out = [str(len(labels)), "generated by gausskit.distort"]
    for lab, (x, y, z) in zip(labels, coords):
        out.append(f"{lab:2s} {x: .8f} {y: .8f} {z: .8f}")
    path.write_text("\n".join(out) + "\n")

def write_gaussian_com(
    path: Path,
    labels: List[str],
    coords: List[List[float]],
    route: str,
    title: str,
    charge: int,
    mult: int,
    chk: str = "",
    oldchk: str = "",
) -> None:
    """Write minimal Gaussian .com with Link-0 directly above route (no blank line)."""
    parts = []
    if oldchk:
        parts.append(f"%OldChk={oldchk}")
    if chk:
        parts.append(f"%Chk={chk}")
    parts.append(route.strip())
    parts.append("")  # blank after route
    parts.append(title)
    parts.append("")  # blank after title
    parts.append(f"{charge: d} {mult:d}")
    for lab, (x, y, z) in zip(labels, coords):
        parts.append(f" {lab:2s}  {x: .8f} {y: .8f} {z: .8f}")
    parts.append("")  # end geometry
    path.write_text("\n".join(parts) + "\n")

# ----------------------------- math helpers -----------------------------

def rms(vecs: List[List[float]]) -> float:
    s = 0.0
    n = 0
    for a in vecs:
        for x in a:
            s += x * x
            n += 1
    return math.sqrt(s / max(n, 1))

def scale_to_amp(vecs: List[List[float]], amp: float) -> List[List[float]]:
    """Normalize mode (or combo) to unit RMS, then scale to amp (Å)."""
    r = rms(vecs)
    if r == 0.0:
        return [[0.0, 0.0, 0.0] for _ in vecs]
    s = amp / r
    return [[x * s, y * s, z * s] for (x, y, z) in vecs]

def add_vecs(a: List[List[float]], b: List[List[float]]) -> List[List[float]]:
    return [[ax + bx, ay + by, az + bz] for (ax, ay, az), (bx, by, bz) in zip(a, b)]

def mul_scalar(vecs: List[List[float]], c: float) -> List[List[float]]:
    return [[c * x, c * y, c * z] for (x, y, z) in vecs]

def displaced_coords(base: List[List[float]], disp: List[List[float]]) -> List[List[float]]:
    return [[bx + dx, by + dy, bz + dz] for (bx, by, bz), (dx, dy, dz) in zip(base, disp)]

# ----------------------------- Gaussian log parsing -----------------------------

def parse_gaussian_modes(log_text: str, natoms: int):
    """
    Parse Gaussian vibrational modes: 'Frequencies -- ...' + 'Atom  AN  X Y Z' tables.
    Returns list of dicts: {'freq': float, 'mode': natoms x 3 list}
    """
    lines = log_text.splitlines()
    modes = []
    i = 0
    while i < len(lines):
        line = lines[i]
        if line.strip().startswith("Frequencies --"):
            parts = line.split()
            # 'Frequencies --  123.4  234.5  345.6' -> parts[2:]
            freqs = []
            for tok in parts[2:]:
                try:
                    freqs.append(float(tok))
                except Exception:
                    break
            nm = len(freqs)

            # find "Atom  AN" header
            j = i + 1
            while j < len(lines) and not lines[j].lstrip().startswith("Atom"):
                j += 1
            if j >= len(lines):
                break

            # Prepare block: nm modes, natoms vectors each
            block = [ [[0.0, 0.0, 0.0] for _ in range(natoms)] for _ in range(nm) ]
            for a in range(natoms):
                j += 1
                if j >= len(lines):
                    break
                toks = lines[j].split()
                # Expect: Center  AN  Type  X  Y  Z  X  Y  Z  X  Y  Z ...
                if len(toks) < 2 + 3 * nm:
                    break
                for m in range(nm):
                    try:
                        x = float(toks[2 + 3*m + 0]); y = float(toks[2 + 3*m + 1]); z = float(toks[2 + 3*m + 2])
                    except Exception:
                        x = y = z = 0.0
                    block[m][a] = [x, y, z]

            for k, f in enumerate(freqs):
                modes.append({"freq": f, "mode": block[k]})

            i = j
        else:
            i += 1
    return modes

def parse_gaussian_geometry(
    log_text: str,
    orientation: str = "standard",  # 'standard' or 'input'
    which: str = "last",            # 'last' or 'first'
) -> Tuple[List[str], List[List[float]]]:
    """
    Extract geometry from Gaussian log's 'Standard orientation:' or 'Input orientation:' table.
    Returns (labels, coords[Å]).
    """
    tag = "Standard orientation" if orientation.lower().startswith("s") else "Input orientation"
    lines = log_text.splitlines()
    blocks = []  # each block is list of (Z, x, y, z)
    i = 0
    while i < len(lines):
        if lines[i].strip().startswith(tag):
            j = i + 1
            # find two dashed lines (header separators)
            dashes = 0
            while j < len(lines):
                if lines[j].strip().startswith("--"):
                    dashes += 1
                    j += 1
                    if dashes == 2:
                        break
                else:
                    j += 1
            if dashes < 2 or j >= len(lines):
                i += 1
                continue
            # read rows until next dashed line
            rows = []
            while j < len(lines) and not lines[j].strip().startswith("--"):
                toks = lines[j].split()
                # Expect: Center  Z  Type  X  Y  Z  (at least 6 tokens)
                if len(toks) >= 6:
                    try:
                        Z = int(toks[1])
                        x = float(toks[-3]); y = float(toks[-2]); z = float(toks[-1])
                        rows.append((Z, x, y, z))
                    except Exception:
                        pass
                j += 1
            if rows:
                blocks.append(rows)
            i = j
        else:
            i += 1

    if not blocks:
        raise ValueError(f"No '{tag}:' geometry tables found in log.")

    blk = blocks[-1] if which == "last" else blocks[0]
    labels = [PT[Z] if 0 < Z < len(PT) else f"X{Z}" for (Z, _, _, _) in blk]
    coords  = [[x, y, z] for (_, x, y, z) in blk]
    return labels, coords

# ----------------------------- printing helpers -----------------------------

def print_mode_summary(modes):
    print(f"Found {len(modes)} modes")
    for idx, m in enumerate(modes, start=1):
        print(f"  Mode {idx:3d} : {m['freq']:10.4f} cm^-1  (RMS={rms(m['mode']):.6f})")

def print_modes_detail(modes, which: List[int], labels: List[str]):
    for idx in which:
        if idx < 1 or idx > len(modes):
            print(f"[warn] Mode {idx} out of range (1..{len(modes)}).")
            continue
        m = modes[idx - 1]
        print(f"\n=== Mode {idx} : {m['freq']:.4f} cm^-1 ===")
        print(" Atom   Label         dX           dY           dZ")
        for a, (lab, (x, y, z)) in enumerate(zip(labels, m["mode"]), start=1):
            print(f"{a:5d}   {lab:>2s}   {x:11.6f} {y:11.6f} {z:11.6f}")

# ----------------------------- CLI (flags) -----------------------------

def main():
    ap = argparse.ArgumentParser(description="Displace a geometry along modes parsed from a Gaussian log.")
    ap.add_argument("--xyz", type=Path, default=None, help="External XYZ for base geometry (standard or headerless).")
    ap.add_argument("--log", type=Path, required=True, help="Gaussian log/output with 'Frequencies --' and orientations.")
    ap.add_argument("--geom-source", choices=["auto","xyz","log"], default="auto",
                    help="Where to read base geometry from. auto: xyz if given else log (default).")
    ap.add_argument("--orientation", choices=["standard","input"], default="standard",
                    help="When --geom-source=log, pick Standard or Input orientation (default: standard).")
    ap.add_argument("--geom-which", choices=["last","first"], default="last",
                    help="When taking geometry from log, choose last or first occurrence (default: last).")
    ap.add_argument("--list", action="store_true", help="List mode frequencies and exit.")
    ap.add_argument("--modes", type=int, nargs="*", default=[], help="Mode indices (1-based) to make ± displacements.")
    ap.add_argument("--amp", type=float, default=0.08, help="RMS amplitude in Å (default 0.08).")
    ap.add_argument("--random", type=int, default=0, help="Make N random linear-combo distortions (RMS=amp).")
    ap.add_argument("--seed", type=int, default=0, help="Random seed (0 = nondeterministic).")
    ap.add_argument("--print-modes", action="store_true", help="Print per-atom components for selected --modes.")
    ap.add_argument("--print-geom", action="store_true", help="Echo first few atoms of the base geometry.")
    ap.add_argument("--out-prefix", default="distort", help="Prefix for generated files (XYZ/.com).")
    # Gaussian output options
    ap.add_argument("--gaussian", action="store_true", help="Also write Gaussian .com for each generated structure.")
    ap.add_argument("--route", default="#p uWB97X-D/def2-svp scf=(pimom,novaracc,maxcycle=256) guess=read chkbasis nosymm",
                    help="Gaussian route line if --gaussian.")
    ap.add_argument("--title", default="Distorted seed", help="Gaussian title if --gaussian.")
    ap.add_argument("--charge", type=int, default=-1, help="Charge for .com (default -1).")
    ap.add_argument("--mult", type=int, default=22, help="Multiplicity for .com (default 22).")
    ap.add_argument("--chk-prefix", default="", help="If set, write %%Chk as <chk-prefix>_<tag>.chk in .com.")
    ap.add_argument("--oldchk", default="", help="If set, include %%OldChk=<value> in .com.")
    ap.add_argument("--submit", action="store_true",
                    help="After writing each .com, prompt to submit to SLURM (uses gausskit.utils.prompt_and_submit).")
    ap.add_argument("--samples-per-mode", type=int, default=1,
                    help="Generate K random-amplitude structures per selected mode (K>1 => random in [0, amp]).")
    ap.add_argument("--samples-plus-only", action="store_true",
                    help="When sampling per mode, write only the + variant (default: both + and −).")
    

    args = ap.parse_args()

    # Read log and parse modes
    log_text = args.log.read_text(errors="ignore")

    # Decide base geometry source
    if args.geom_source == "xyz" or (args.geom_source == "auto" and args.xyz is not None):
        labels, coords = read_xyz(args.xyz)  # type: ignore
        base_src = f"XYZ:{args.xyz.name}" if args.xyz else "XYZ"
    else:
        labels, coords = parse_gaussian_geometry(log_text, orientation=args.orientation, which=args.geom_which)
        base_src = f"LOG:{args.orientation}/{args.geom_which}"

    if args.print_geom:
        print(f"[geom] loaded {len(labels)} atoms from {base_src}")
        for i, (lab, (x,y,z)) in enumerate(zip(labels, coords), start=1):
            if i > 6:  # show first few only
                print(f"... ({len(labels)-6} more atoms)")
                break
            print(f"  {i:3d} {lab:>2s}  {x: .6f} {y: .6f} {z: .6f}")

    # Parse modes now that we know natoms
    modes = parse_gaussian_modes(log_text, natoms=len(labels))
    if not modes:
        raise SystemExit("No vibrational modes parsed. Does the log contain a frequency job?")

    if args.list:
        print_mode_summary(modes)
        return

    if args.seed:
        random.seed(args.seed)

    if not args.modes and args.random == 0:
        print("Nothing to do. Use --list, or --modes … and/or --random N. Try --help for options.")
        return

    out_dir = Path(".")

    ## Generate ± displacements for explicit modes
    #for m_idx in args.modes:
    #    if m_idx < 1 or m_idx > len(modes):
    #        print(f"[warn] Mode {m_idx} out of range (1..{len(modes)}); skipping.")
    #        continue
    #    disp = scale_to_amp([v[:] for v in modes[m_idx - 1]["mode"]], args.amp)
    #    for sign, tag in [(+1, f"m{m_idx:03d}p"), (-1, f"m{m_idx:03d}n")]:
    #        d = mul_scalar(disp, sign)
    #        new_coords = displaced_coords(coords, d)
    #        xyz_path = out_dir / f"{args.out_prefix}_{tag}.xyz"
    #        write_xyz(xyz_path, labels, new_coords)
    #        if args.gaussian:
    #            chk_prefix = args.chk_prefix or args.out_prefix
    #            chk = f"{chk_prefix}_{tag}.chk"
    #            com_path = out_dir / f"{args.out_prefix}_{tag}.com"
    #            write_gaussian_com(
    #                com_path, labels, new_coords, route=args.route, title=args.title,
    #                charge=args.charge, mult=args.mult, chk=chk, oldchk=args.oldchk
    #            )
    #            if args.submit:
    #                prompt_and_submit(str(com_path))
    # Generate per-mode structures (± fixed amp, or K random-amplitude samples)
    chk_prefix = args.chk_prefix or args.out_prefix  # auto-prefix if none was passed
    for m_idx in args.modes:
        if m_idx < 1 or m_idx > len(modes):
            print(f"[warn] Mode {m_idx} out of range (1..{len(modes)}); skipping.")
            continue
    
        # Unit-RMS direction for this mode; we scale by (fraction * args.amp)
        unit = scale_to_amp([v[:] for v in modes[m_idx - 1]["mode"]], 1.0)
    
        def emit(scale_frac: float, sign: int, tag_suffix: str):
            disp = mul_scalar(unit, scale_frac * args.amp * sign)
            new_coords = displaced_coords(coords, disp)
            xyz_path = out_dir / f"{args.out_prefix}_{tag_suffix}.xyz"
            write_xyz(xyz_path, labels, new_coords)
            if args.gaussian:
                chk = f"{chk_prefix}_{tag_suffix}.chk"
                com_path = out_dir / f"{args.out_prefix}_{tag_suffix}.com"
                write_gaussian_com(
                    com_path, labels, new_coords, route=args.route, title=args.title,
                    charge=args.charge, mult=args.mult, chk=chk, oldchk=args.oldchk
                )
                if args.submit:
                    prompt_and_submit(str(com_path))
    
        if args.samples_per_mode <= 1:
            # Original behavior: full amp, write ±
            emit(1.0, +1, f"m{m_idx:03d}p")
            emit(1.0, -1, f"m{m_idx:03d}n")
        else:
            # K samples with random magnitude in (0, 1] * amp
            for j in range(args.samples_per_mode):
                frac = max(1e-8, random.random())  # avoid exact zero
                if args.samples_plus_only:
                    emit(frac, +1, f"m{m_idx:03d}_r{j+1:02d}")
                else:
                    emit(frac, +1, f"m{m_idx:03d}_r{j+1:02d}p")
                    emit(frac, -1, f"m{m_idx:03d}_r{j+1:02d}n")
    

    # Random linear combos (use selected pool if --modes given, else all modes)
    pool = [modes[i - 1]["mode"] for i in args.modes if 1 <= i <= len(modes)] if args.modes else [m["mode"] for m in modes]
    for k in range(args.random):
        coeffs = [2.0*random.random()-1.0 for _ in pool]
        combo = [[0.0, 0.0, 0.0] for _ in coords]
        for c, disp in zip(coeffs, pool):
            combo = add_vecs(combo, mul_scalar(disp, c))
        combo = scale_to_amp(combo, args.amp)
        new_coords = displaced_coords(coords, combo)
        tag = f"rand{k+1:02d}"
        xyz_path = out_dir / f"{args.out_prefix}_{tag}.xyz"
        write_xyz(xyz_path, labels, new_coords)
        if args.gaussian:
            chk = f"{args.chk_prefix}_{tag}.chk" if args.chk_prefix else ""
            com_path = out_dir / f"{args.out_prefix}_{tag}.com"
            write_gaussian_com(
                com_path, labels, new_coords, route=args.route, title=args.title,
                charge=args.charge, mult=args.mult, chk=chk, oldchk=args.oldchk
            )
            if args.submit:
                prompt_and_submit(str(com_path))

# ----------------------------- Wizard helpers -----------------------------

def _parse_int_list(spec: str, hi: int) -> List[int]:
    """
    Parse '1,3-5,8' into [1,3,4,5,8]; clamp to [1..hi]; unique, sorted.
    Empty/invalid -> [].
    """
    out = set()
    spec = (spec or "").replace(" ", "")
    if not spec:
        return []
    for chunk in spec.split(","):
        if not chunk:
            continue
        if "-" in chunk:
            try:
                lo_s, up_s = chunk.split("-", 1)
                lo, up = int(lo_s), int(up_s)
                lo = max(1, lo)
                up = min(hi, up)
                if lo <= up:
                    out.update(range(lo, up + 1))
            except Exception:
                pass
        else:
            try:
                v = int(chunk)
                if 1 <= v <= hi:
                    out.add(v)
            except Exception:
                pass
    return sorted(out)

# ----------------------------- Interactive wizard -----------------------------

def interactive_distort_wizard():
    print("=" * 70)
    print(" Distort geometry along vibrational modes (interactive wizard) ")
    print("=" * 70)

    # --- Choose files (combined, comma-aware) ---------------------------------
    raw_files = prompt(
        "Select files ('.log'[ , '.xyz']): ",
        completer=MultiPathCompleter(file_filter=lambda f: f.endswith(".log") or f.endswith(".xyz"))
    ).strip()

    log_path: Optional[Path] = None
    xyz_path: Optional[Path] = None
    if raw_files:
        paths = [Path(p.strip()) for p in raw_files.split(",") if p.strip()]
        for p in paths:
            suf = p.suffix.lower()
            if suf == ".log" and log_path is None:
                log_path = p
            elif suf == ".xyz" and xyz_path is None:
                xyz_path = p

    if log_path is None:
        lp = prompt(
            "Gaussian log with frequencies (*.log): ",
            completer=PathCompleter(file_filter=lambda f: f.endswith(".log"))
        ).strip()
        if not lp:
            print("No log selected. Aborting.")
            return
        log_path = Path(lp)

    if not log_path.exists():
        print(f"Log not found: {log_path}")
        return

    log_text = log_path.read_text(errors="ignore")

    # Decide geometry source:
    #  - If user already supplied an .xyz in the one-shot picker, use it.
    #  - Otherwise ask to use geometry from the log OR browse for an .xyz.
    if xyz_path is None:
        geom_src_ans = (prompt("Geometry source [1=log / 2=xyz, default=1]: ").strip() or "1")
        use_xyz = (geom_src_ans == "2")
    else:
        use_xyz = True

    labels: List[str]; coords: List[List[float]]
    if use_xyz:
        if xyz_path is None:
            xp = prompt(
                "XYZ file (supports standard or headerless): ",
                completer=PathCompleter(file_filter=lambda f: f.endswith(".xyz"))
            ).strip()
            if not xp:
                print("No XYZ selected. Aborting.")
                return
            xyz_path = Path(xp)

        if not xyz_path.exists():
            print(f"XYZ not found: {xyz_path}")
            return
        labels, coords = read_xyz(xyz_path)
        base_src = f"XYZ:{xyz_path.name}"
    else:
        o = (prompt("Orientation [1=Standard / 2=Input, default=1]: ").strip() or "1")
        w = (prompt("Which table [1=last / 2=first, default=1]: ").strip() or "1")
        orientation = "standard" if o == "1" else "input"
        which = "last" if w == "1" else "first"
        labels, coords = parse_gaussian_geometry(log_text, orientation=orientation, which=which)
        base_src = f"LOG:{orientation}/{which}"

    print(f"[geom] loaded {len(labels)} atoms from {base_src}")
    print(f"  log = {log_path}")
    if use_xyz:
        print(f"  xyz = {xyz_path}")

    # --- Parse modes ----------------------------------------------------------
    modes = parse_gaussian_modes(log_text, natoms=len(labels))
    if not modes:
        print("No vibrational modes parsed. Is this a frequency job?")
        return

    show = (prompt("List modes now? [Y/n]: ").strip().lower() or "y").startswith("y")
    if show:
        print_mode_summary(modes)

    # --- Choose actions -------------------------------------------------------
    sel = prompt("Modes to displace (e.g., 1,3-5) [ENTER=none]: ").strip()
    which_modes = _parse_int_list(sel, hi=len(modes))

    rnd = prompt("Random linear combinations N [ENTER=0]: ").strip() or "0"
    try:
        n_rand = max(0, int(rnd))
    except Exception:
        n_rand = 0

    if not which_modes and n_rand == 0:
        print("Nothing to do (no modes and zero random). Aborting.")
        return

    amp = prompt("RMS amplitude in Angstrom (default 0.08): ").strip() or "0.08"
    try:
        amp_val = float(amp)
    except Exception:
        amp_val = 0.08

    if amp_val > 0.3:
        ans = (prompt(f"Amplitude {amp_val:g} Å is quite large (recommended ≤ 0.2 Å). "
                      f"Proceed anyway? [y/N]: ").strip().lower() or "n")
        if not ans.startswith("y"):
            amp_in = prompt("Enter a smaller amplitude (e.g., 0.08): ").strip() or "0.08"
            try:
                amp_val = float(amp_in)
            except Exception:
                amp_val = 0.08

    # Multiple random-amplitude structures per selected mode?
    multi_per_mode = (prompt("Generate multiple random-amplitude structures per mode? [y/N]: ")
                      .strip().lower() or "n").startswith("y")
    per_mode_count = 1
    both_signs = True
    if multi_per_mode:
        per_mode_count = int(prompt("How many per mode? [default=3]: ").strip() or "3")
        both_signs = (prompt("For each sample, write both + and − variants? [Y/n]: ")
                      .strip().lower() or "y").startswith("y")
        # (optional) a seed just for this feature
        seed_ans = prompt("Random seed for per-mode sampling [ENTER=nondeterministic]: ").strip()
        if seed_ans:
            try:
                random.seed(int(seed_ans))
            except Exception:
                pass
    

    out_prefix = prompt("Output prefix (default 'distort'): ").strip() or "distort"
    chk_prefix = out_prefix

    # --- Gaussian outputs? ----------------------------------------------------
    mk_com = (prompt("Also write Gaussian .com files? [Y/n]: ").strip().lower() or "y").startswith("y")
    route = "#p uWB97X-D/def2-tzvp scf=(novaracc,xqc) int=superfinegrid"
    title = "Distorted seed"
    charge = -1
    mult = 2
    chk_prefix = ""
    oldchk = ""

    if mk_com:
        r = prompt("Route line [ENTER for default]: ").strip()
        if r:
            route = r
        t = prompt("Title [ENTER=Distorted seed]: ").strip()
        if t:
            title = t
        c = prompt(f"Charge [ENTER={charge}]: ").strip()
        if c:
            try:
                charge = int(c)
            except Exception:
                pass
        m = prompt(f"Multiplicity [ENTER={mult}]: ").strip()
        if m:
            try:
                mult = int(m)
            except Exception:
                pass
#        oldchk = prompt("%%OldChk value (optional) [ENTER=skip]: ").strip()
        oldchk = prompt(
            "Select %OldChk file (TAB to browse) [ENTER=skip]: ",
            completer=PathCompleter(
                expanduser=True,
                file_filter=lambda p: p.lower().endswith((".chk"))
            ),
        ).strip()
        
        #chk_prefix = prompt("%%Chk prefix (optional, used as '<prefix>_<tag>.chk') [ENTER=skip]: ").strip()

    do_submit = False
    if mk_com:
        do_submit = (prompt("Submit each .com to SLURM? [y/N]: ").strip().lower() or "n").startswith("y")

    pgeom = (prompt("Print first few atoms of base geometry? [y/N]: ").strip().lower() or "n").startswith("y")
    if pgeom:
        for i, (lab, (x, y, z)) in enumerate(zip(labels, coords), start=1):
            if i > 6:
                print(f"... ({len(labels) - 6} more atoms)")
                break
            print(f"  {i:3d} {lab:>2s}  {x: .6f} {y: .6f} {z: .6f}")
    chk_prefix = out_prefix


    # --- Summary --------------------------------------------------------------
    print("\nPlan:")
    if which_modes:
        print(f"  Modes: {which_modes}  (± per mode)")
    if n_rand:
        print(f"  Random combos: {n_rand}")
    print(f"  Amplitude: {amp_val} Å RMS")
    print(f"  Prefix: {out_prefix}")
    if mk_com:
        print(f"  .com: YES  (charge={charge}, mult={mult})")
        print(f"  Route: {route}")
        if oldchk:
            print(f"  %OldChk={oldchk}")
        if chk_prefix:
            print(f"  %Chk=<{chk_prefix}_TAG>.chk")
        print(f"  SLURM submit: {'YES' if do_submit else 'no'}")
    else:
        print("  .com: no")

    ok = (prompt("\nProceed? [Y/n]: ").strip().lower() or "y").startswith("y")
    if not ok:
        print("Aborted.")
        return

    # --- Execute --------------------------------------------------------------
    out_dir = Path(".")
   # # specific modes (±)
   # for m_idx in which_modes:
   #     if m_idx < 1 or m_idx > len(modes):
   #         print(f"[warn] Mode {m_idx} out of range (1..{len(modes)})")
   #         continue
   #     disp = scale_to_amp([v[:] for v in modes[m_idx - 1]["mode"]], amp_val)
   #     for sign, tag in [(+1, f"m{m_idx:03d}p"), (-1, f"m{m_idx:03d}n")]:
   #         d = mul_scalar(disp, sign)
   #         new_coords = displaced_coords(coords, d)
   #         xyz_path = out_dir / f"{out_prefix}_{tag}.xyz"
   #         write_xyz(xyz_path, labels, new_coords)
   #         if mk_com:
   #             chk = f"{chk_prefix}_{tag}.chk" if chk_prefix else ""
   #             com_path = out_dir / f"{out_prefix}_{tag}.com"
   #             write_gaussian_com(
   #                 com_path, labels, new_coords, route=route, title=title,
   #                 charge=charge, mult=mult, chk=chk, oldchk=oldchk
   #             )
   #             if do_submit:
   #                 prompt_and_submit(str(com_path))
    # specific modes (± or random-amplitude samples)
    for m_idx in which_modes:
        if m_idx < 1 or m_idx > len(modes):
            print(f"[warn] Mode {m_idx} out of range (1..{len(modes)})")
            continue
    
        # Build a unit-RMS direction first; we’ll scale by (fraction * amp_val)
        unit = scale_to_amp([v[:] for v in modes[m_idx - 1]["mode"]], 1.0)
    
        def emit(scale_frac: float, sign: int, tag_suffix: str):
            disp = mul_scalar(unit, scale_frac * amp_val * sign)
            new_coords = displaced_coords(coords, disp)
            xyz_path = out_dir / f"{out_prefix}_{tag_suffix}.xyz"
            write_xyz(xyz_path, labels, new_coords)
            if mk_com:
                chk = f"{chk_prefix}_{tag_suffix}.chk" if chk_prefix else ""
                com_path = out_dir / f"{out_prefix}_{tag_suffix}.com"
                write_gaussian_com(
                    com_path, labels, new_coords, route=route, title=title,
                    charge=charge, mult=mult, chk=chk, oldchk=oldchk
                )
                if do_submit:
                    prompt_and_submit(str(com_path))
    
        if not multi_per_mode or per_mode_count <= 1:
            # Original behavior: fixed amplitude, write ± pair
            emit(1.0, +1, f"m{m_idx:03d}p")
            emit(1.0, -1, f"m{m_idx:03d}n")
        else:
            # Random magnitude for each sample: U ~ Uniform(0, 1], scaled by amp_val
            for j in range(per_mode_count):
                frac = max(1e-8, random.random())  # avoid exact zero
                if both_signs:
                    emit(frac, +1, f"m{m_idx:03d}_r{j+1:02d}p")
                    emit(frac, -1, f"m{m_idx:03d}_r{j+1:02d}n")
                else:
                    # plus-only
                    emit(frac, +1, f"m{m_idx:03d}_r{j+1:02d}")
    

    # random linear combos
    pool = [modes[i - 1]["mode"] for i in which_modes] if which_modes else [m["mode"] for m in modes]
    if n_rand > 0:
        seed_ans = prompt("Random seed [ENTER=nondeterministic]: ").strip()
        if seed_ans:
            try:
                random.seed(int(seed_ans))
            except Exception:
                pass
        for k in range(n_rand):
            coeffs = [2.0 * random.random() - 1.0 for _ in pool]
            combo = [[0.0, 0.0, 0.0] for _ in coords]
            for c, disp in zip(coeffs, pool):
                combo = add_vecs(combo, mul_scalar(disp, c))
            combo = scale_to_amp(combo, amp_val)
            new_coords = displaced_coords(coords, combo)
            tag = f"rand{k + 1:02d}"
            xyz_path = out_dir / f"{out_prefix}_{tag}.xyz"
            write_xyz(xyz_path, labels, new_coords)
            if mk_com:
                chk = f"{chk_prefix}_{tag}.chk" if chk_prefix else ""
                com_path = out_dir / f"{out_prefix}_{tag}.com"
                write_gaussian_com(
                    com_path, labels, new_coords, route=route, title=title,
                    charge=charge, mult=mult, chk=chk, oldchk=oldchk
                )
                if do_submit:
                    prompt_and_submit(str(com_path))

    print("\nDone.")

# ----------------------------- Adapter (flags vs wizard) -----------------------------

def run_distort_cli():
    """
    Entry point used by GaussKit dispatcher.
    If the user supplied flags, use argparse path (automation).
    If not, launch the interactive wizard.
    """
    if len(sys.argv) > 1:
        return main()
    return interactive_distort_wizard()

if __name__ == "__main__":
    run_distort_cli()

